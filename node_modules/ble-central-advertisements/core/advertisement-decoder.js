import { isArrayBuffer, isObject, isUint8Array } from '../common/utility';
import { uint8ArrayToUTF8, uint8ArrayTo16BitServiceUuids } from '../common/convert';
import { GapAdvertisementFlagType, isGapAdvertisementFlagRaised } from '../gap/gap-advertisement-flag-type';
import { parseGapAttributesMetadata } from '../gap/gap-attributes-metadata';
import { isIOSAdvertisingData } from '../plugin/ios-advertising-data';
function cloneIOSAdvertisingData(target, adv) {
    target.advDataChannel = adv.kCBAdvDataChannel;
    target.advDataLocalName = adv.kCBAdvDataLocalName;
    target.advDataTxPowerLevel = adv.kCBAdvDataTxPowerLevel;
    target.advDataIsConnectable = adv.kCBAdvDataIsConnectable;
    target.advDataServiceUUIDs = adv.kCBAdvDataServiceUUIDs;
    target.advDataManufacturerData = adv.kCBAdvDataManufacturerData;
    target.advDataServiceData = adv.kCBAdvDataServiceData;
}
function populateAdvertisementFromGap(target, gap, options) {
    const localNameBuffer = options.useShortenedLocalName
        ? gap.localNameShortened
        : gap.localNameComplete;
    target.gap = gap;
    target.advDataLocalName = uint8ArrayToUTF8(localNameBuffer);
    target.advDataServiceUUIDs = uint8ArrayTo16BitServiceUuids(gap.completeListOfServiceUuids16Bit);
    if (isUint8Array(gap.flags)) {
        const flags = target.gapFlags = gap.flags[0];
        target.advDataIsConnectable = isGapAdvertisementFlagRaised(flags, GapAdvertisementFlagType.LE_GENERAL_DISC_MODE);
    }
    if (isUint8Array(gap.channelMapUpdateIndication))
        target.advDataChannel = gap.channelMapUpdateIndication[0];
    if (isUint8Array(gap.txPowerLevel))
        target.advDataTxPowerLevel = gap.txPowerLevel[0];
    if (isUint8Array(gap.manufacturerSpecificData))
        target.advDataManufacturerData = gap.manufacturerSpecificData;
}
/**
 * Generalized decoder that does boilerplate advertising data checks / parsing
 * based on the type of the advertising data recieved.
 *
 * This can be sub-classed to further customize the decode functionality.
 */
export class AdvertisementDecoder {
    constructor(options = {}) {
        this.options = options;
    }
    /**
     * Decode an advertisement payload received from the ble central plugin.
     * If an output value is provided, all parsed content will be placed on
     * it - otherwise, parsed content will be shimmed into the provided
     * input value, and that value will be returned.
     *
     * NOTE: if the input is an ArrayBuffer, this will generate a new
     * object as the output rather than hammering properties onto
     * the ArrayBuffer instance.
     */
    decode(input, output) {
        let result = isObject(output)
            ? output
            : input;
        // nothing to process, abort
        if (!isObject(input))
            return result;
        const isBufferSource = isArrayBuffer(input);
        // don't allow shimming properties onto buffer sources
        if (result === input && isBufferSource)
            result = {};
        const advertising = isBufferSource
            ? input
            : input.advertising;
        if (isArrayBuffer(advertising)) {
            const buffer = new Uint8Array(advertising);
            const gap = parseGapAttributesMetadata(buffer);
            populateAdvertisementFromGap(result, gap, this.options);
        }
        else if (isIOSAdvertisingData(advertising)) {
            cloneIOSAdvertisingData(result, advertising);
        }
        return result;
    }
}
