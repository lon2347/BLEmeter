import { GapAttributesMetadata } from '../gap/gap-attributes-metadata';
import { iOSAdvertisingServiceDataDictionary } from '../plugin/ios-advertising-data';
import { PluginAdvertisement } from '../plugin/plugin-advertisement';
export interface AdvertisingServiceDataDictionary extends iOSAdvertisingServiceDataDictionary {
}
/**
 * Shares common fields between android and ios payloads,
 * and masks platform-specific fields as generalized ones.
 */
export interface Advertisement extends PluginAdvertisement {
    gap?: GapAttributesMetadata;
    gapFlags?: number;
    advDataChannel?: number;
    advDataLocalName?: string;
    advDataTxPowerLevel?: number;
    advDataIsConnectable?: boolean;
    advDataServiceUUIDs?: string[];
    advDataManufacturerData?: ArrayBuffer;
    advDataServiceData?: AdvertisingServiceDataDictionary;
}
/**
 * Customization options for decoder instances.
 */
export interface AdvertisementDecoderOptions {
    useShortenedLocalName?: boolean;
    [key: string]: any;
}
/**
 * Generalized decoder that does boilerplate advertising data checks / parsing
 * based on the type of the advertising data recieved.
 *
 * This can be sub-classed to further customize the decode functionality.
 */
export declare class AdvertisementDecoder {
    private readonly options;
    constructor(options?: AdvertisementDecoderOptions);
    /**
     * Decode an advertisement payload received from the ble central plugin.
     * If an output value is provided, all parsed content will be placed on
     * it - otherwise, parsed content will be shimmed into the provided
     * input value, and that value will be returned.
     *
     * NOTE: if the input is an ArrayBuffer, this will generate a new
     * object as the output rather than hammering properties onto
     * the ArrayBuffer instance.
     */
    decode(input: PluginAdvertisement | Partial<PluginAdvertisement> | ArrayBuffer, output?: Partial<Advertisement>): Advertisement | Partial<Advertisement>;
}
